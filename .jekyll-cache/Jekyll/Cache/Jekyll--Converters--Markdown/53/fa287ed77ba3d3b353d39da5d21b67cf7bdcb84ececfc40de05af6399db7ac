I"˙˚<h1 id="1-table-of-contents">1. Table of contents</h1>
<!-- TOC -->

<ul>
  <li><a href="#1-table-of-contents">1. Table of contents</a></li>
  <li><a href="#2-introduction">2. Introduction</a>
    <ul>
      <li><a href="#21-the-fastq-format">2.1. The fastq format</a></li>
    </ul>
  </li>
  <li><a href="#3-quality-control-of-fastq-files">3. Quality control of FASTQ files</a>
    <ul>
      <li><a href="#31-running-fastqc">3.1. Running FastQC</a></li>
      <li><a href="#32-viewing-the-fastqc-results">3.2. Viewing the FastQC results</a>
        <ul>
          <li><a href="#321-decoding-the-fastqc-outputs">3.2.1. Decoding the FastQC outputs</a></li>
          <li><a href="#322-sequencing-error-profiles">3.2.2. Sequencing error profiles</a></li>
          <li><a href="#323-expected-errors">3.2.3. Expected Errors</a></li>
          <li><a href="#324-worrisome">3.2.4. Worrisome</a></li>
          <li><a href="#325-quality-assessment">3.2.5. Quality assessment</a></li>
          <li><a href="#326-per-sequence-quality-scores">3.2.6. Per sequence quality scores</a></li>
          <li><a href="#327-per-base-sequence-content">3.2.7. Per base sequence content</a></li>
          <li><a href="#328-per-sequence-gc-content">3.2.8. Per sequence GC content</a></li>
          <li><a href="#329-sequence-duplication-level">3.2.9. Sequence duplication level</a></li>
          <li><a href="#3210-overrepresented-sequences">3.2.10. Overrepresented sequences</a></li>
        </ul>
      </li>
      <li><a href="#33-working-with-the-fastqc-text-output">3.3. Working with the FastQC text output</a></li>
      <li><a href="#34-documenting-our-work">3.4. Documenting our work</a></li>
    </ul>
  </li>
  <li><a href="#4-trimming-and-filtering">4. Trimming and filtering</a></li>
  <li><a href="#5-alignment-to-a-reference-genome">5. Alignment to a reference genome</a>
    <ul>
      <li><a href="#51-index-the-reference-genome">5.1. Index the reference genome</a></li>
      <li><a href="#52-align-reads-to-reference-genome">5.2. Align reads to reference genome</a></li>
      <li><a href="#53-the-sambam-format">5.3. The SAM/BAM format</a></li>
    </ul>
  </li>
  <li><a href="#6-creating-the-counts-file">6. Creating the counts file</a></li>
  <li><a href="#7-removal-of-container-and-image">7. Removal of Container and Image</a></li>
  <li><a href="#8-keypoints">8. Keypoints</a></li>
</ul>

<!-- /TOC -->

<p><img src="../img/04-workflow-overview.png" width="500px" alt="workflow overview" /></p>

<h1 id="2-introduction">2. Introduction</h1>

<h2 id="21-the-fastq-format">2.1. The fastq format</h2>

<p>Check the Wikipedia page for now: https://en.wikipedia.org/wiki/FASTQ_format</p>

<p>The first step in the RNA-Seq workflow is to take the FASTQ files received from the sequencing facility and assess the quality of the sequence reads.</p>

<p><strong>Unmapped read data (FASTQ)</strong></p>

<p>The <a href="https://en.wikipedia.org/wiki/FASTQ_format">FASTQ</a> file format is the defacto file format for sequence reads generated from next-generation sequencing technologies. This file format evolved from FASTA in that it contains sequence data, but also contains quality information. Similar to FASTA, the FASTQ file begins with a header line. The difference is that the FASTQ header is denoted by a <code class="highlighter-rouge">@</code> character. For a single record (sequence read) there are four lines, each of which are described below:</p>

<table>
  <thead>
    <tr>
      <th>Line</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Always begins with ‚Äò@‚Äô and then information about the read</td>
    </tr>
    <tr>
      <td>2</td>
      <td>The actual DNA sequence</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Always begins with a ‚Äò+‚Äô and sometimes the same info in line 1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Has a string of characters which represent the quality scores; must have same number of characters as line 2</td>
    </tr>
  </tbody>
</table>

<p>Let‚Äôs start and enter the container and have a look what the files we will be using actualy look like.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -it --name bioinfo scienceparkstudygroup/master-gls:fastq-latest

$ conda activate fastq

$ cd home
</code></pre></div></div>

<p>As you can see the <code class="highlighter-rouge">/home/</code> directory contains 4 fastq files. The files are generaly quite big (they usualy contain up to 40 milion reads), so it‚Äôs a smart thing to keep them zipped as they are.
<code class="highlighter-rouge">zcat</code> is a simular function as <code class="highlighter-rouge">cat</code> but works on zipped files. With the use of this function we can have a look at the files without having to unzip them.</p>
<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ zcat Arabidopsis_sample2.fq.gz | head -n 20
</code></pre></div></div>
<p>This will show the first 20 lines of the file, containing 5 reads.</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@ERR1406259.27450842
CATCGCTGAAGATCTGTGAACCAGCCTTGAACCAAACTGCCTCTCCAAACTTGACTCCGTTCCTGGCCAAAAGCTCAGGGAAGACGCAGCCTAGGGCTCCG
+
?ABEEEDCBFEDGHFJFJIHFEFCC=&gt;BEC&gt;FJ@GHCHBHCGFJHG;:F&lt;AI;90F=E44:8FA&gt;@8C;;33237-?84(&gt;*$A#$#/B.5)-&gt;0%/8D=;
@ERR1406259.27450849
GTTTTTTTCACTTGATAAATTTGCATTTTAAAACACACTTCATGGATAAAACGGATCATTTCTTGCCACTCTTCTTAAGTCCAGAACCTCCAAAGGATCCC
+
@@?DFCBEEHCDFIFJEGEFGHEDIC&gt;DHFFEF@FH&gt;FG@FA;C9B=B&gt;FHE09C&lt;DE&gt;;H:EH4C/D341;-B,&lt;&gt;:67+--,0;32@8'D)&lt;B@&gt;'&amp;4!
@ERR1406259.27450850
GTAACTAACCCTGTCTCGAGCCGTTGTCATGAACAAGAACGCTGCGTGGCCTAACCCTGCTAGCTTCGTGGACAGAACCATGTCATAGTACCTTCCTTTGA
+
@&gt;=BEBCEFEBHHFEJHDCJHFDFGBFGEIE=IF?DDAJ?A@=8FI&lt;@:C7B;:43G77434;*64&lt;9=63+,:3/4/A0';(6B3=%45/&gt;#)&lt;#$=2,-
@ERR1406259.27450851
TTTGGCTTGGCAACAGTCTTCCTCATTGTCACACGGCCGCTTCCAAGGACTTCTGAAGCCGCAGGGGAAAGGTTCACAGCCTTTCCGGCGAAAGCAGGGGA
+
9&lt;&lt;B&gt;:D&lt;?.CC@8C=C/7@1:+8%&gt;+,&amp;!!!4)!'%&amp;75/A;.7B3!!!!#!!!!!!#!#!!!#!!!!!#!#!!!!!#!!!!!!"!!!!!!!!!!!!!!!
@ERR1406259.27450856
GAGAAGGCAAAGGAGAATGATAAAGAACCGAGAATCAGCTGCAAGGTCCCGGGCCAGGAAACAGATATTCACGGCAGACCAAACAATATACTGGAATGTAA
+
&lt;?CEF&gt;&gt;AEDFFBDCAFCCFDHCDD&lt;D;=;GBFA@A&lt;;&lt;;89;8&lt;4:7&gt;;E5&lt;B=9/@=F@:&lt;;:A@/481*&lt;6&amp;-?,9744**71:-43333.,##!,08
</code></pre></div></div>

<p>Let‚Äôs have a close look at the first read of this sample:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@ERR1406259.27450842
CATCGCTGAAGATCTGTGAACCAGCCTTGAACCAAACTGCCTCTCCAAACTTGACTCCGTTCCTGGCCAAAAGCTCAGGGAAGACGCAGCCTAGGGCTCCG
+
?ABEEEDCBFEDGHFJFJIHFEFCC=&gt;BEC&gt;FJ@GHCHBHCGFJHG;:F&lt;AI;90F=E44:8FA&gt;@8C;;33237-?84(&gt;*$A#$#/B.5)-&gt;0%/8D=;
</code></pre></div></div>

<p>As mentioned previously, line 4 has characters encoding the quality of each nucleotide in the read. The legend below provides the mapping of quality scores (Phred-33) to the quality encoding characters. <strong>Different quality encoding scales exist (differing by offset in the ASCII table), but note the most commonly used one is fastqsanger</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Quality encoding: !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHI
                   |         |         |         |         |
    Quality score: 0........10........20........30........40                                
</code></pre></div></div>

<p>Using the quality encoding character legend, the first nucelotide in the read (C) is called with a quality score of 30. The second base (A) has a quality of 32, etc.</p>

<p>Each quality score represents the probability that the corresponding nucleotide call is incorrect. This quality score is logarithmically based and is calculated as:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q = -10 x log10(P), where P is the probability that a base call is erroneous
</code></pre></div></div>

<p>These probabaility values are the results from the base calling algorithm and dependent on how much signal was captured for the base incorporation. The score values can be interpreted as follows:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Phred Quality Score</th>
      <th style="text-align: center">Probability of incorrect base call</th>
      <th style="text-align: right">Base call accuracy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">10</td>
      <td style="text-align: center">1 in 10</td>
      <td style="text-align: right">90%</td>
    </tr>
    <tr>
      <td style="text-align: left">20</td>
      <td style="text-align: center">1 in 100</td>
      <td style="text-align: right">99%</td>
    </tr>
    <tr>
      <td style="text-align: left">30</td>
      <td style="text-align: center">1 in 1000</td>
      <td style="text-align: right">99.9%</td>
    </tr>
    <tr>
      <td style="text-align: left">40</td>
      <td style="text-align: center">1 in 10,000</td>
      <td style="text-align: right">99.99%</td>
    </tr>
  </tbody>
</table>

<p>Therefore, for the first nucleotide in the read (C), there is a 1 in 1000 chance that the base was called incorrectly. Also you can see that the second half of the read contains a lot of bases that have a more then 10% probabaility that the base is called incorrectly.</p>

<blockquote class="challenge">
  <h2 id="question">Question</h2>
  <p>How many reads do these samples contain?</p>
  <blockquote class="solution">
    <h2 id="solution">Solution</h2>
    <p>To get the number of reads, get the number of lines and divide by 4. <code class="highlighter-rouge">zcat Arabidopsis_sample2.fq.gz | wc -l</code> gives 1,000,000 lines -&gt; 250,000 reads.</p>
  </blockquote>
</blockquote>

<h1 id="3-quality-control-of-fastq-files">3. Quality control of FASTQ files</h1>

<h2 id="31-running-fastqc">3.1. Running FastQC</h2>

<p>We will now create the quality reports of the reads that we downloaded. First, we need to make an output directory for the fastqc results to be stored. This we want to do in the ‚Äòhome‚Äô directory that contains all the needed files.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /home/

$ mkdir fastqc
</code></pre></div></div>

<p>Next we need to get to the directory that actually contains the the fastq files.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls /home/
</code></pre></div></div>

<p>Running fastqc uses the following command</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fastqc -o fastqc Arabidopsis_sample1.fq.gz
</code></pre></div></div>

<p>Of course we don‚Äôt want to do this for all the samples seperately so we can loop through the list of samples and run them all sequentially</p>

<p>With the use of echo you can start off with a ‚Äúdry run‚Äù</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ for filename in  *.fq.gz
  do
    echo fastqc -o fastqc $filename
  done
</code></pre></div></div>

<p>The echo command only prints the commands to the screen, and doesn‚Äôt really run it.</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fastqc -o fastqc Arabidopsis_sample1.fq.gz
fastqc -o fastqc Arabidopsis_sample2.fq.gz
fastqc -o fastqc Arabidopsis_sample3.fq.gz
fastqc -o fastqc Arabidopsis_sample4.fq.gz
</code></pre></div></div>

<p>If it looks good remove the echo and go for it.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ for filename in *.fq.gz
  do
    fastqc -o fastqc $filename
  done
</code></pre></div></div>

<p>You will see an automatically updating output message telling you the
progress of the analysis. It should look something like this:</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Started analysis of Arabidopsis_sample1.fq.gz
Approx 5% complete for Arabidopsis_sample1.fq.gz
Approx 10% complete for Arabidopsis_sample1.fq.gz
Approx 15% complete for Arabidopsis_sample1.fq.gz
Approx 20% complete for Arabidopsis_sample1.fq.gz
‚Ä¶
Approx 85% complete for Arabidopsis_sample4.fq.gz
Approx 90% complete for Arabidopsis_sample4.fq.gz
Approx 95% complete for Arabidopsis_sample4.fq.gz
Approx 100% complete for Arabidopsis_sample4.fq.gz
Analysis complete for Arabidopsis_sample4.fq.gz
</code></pre></div></div>

<p>In total, it should take about five minutes for FastQC to run on all
four of our zipped FASTQ files.</p>

<p>If the command doesn‚Äôt run or you want more information on fastqc, run the following to get the help page.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ fastqc -h
</code></pre></div></div>

<p>But if all went right, the FastQC program will have created several new files within our
<code class="highlighter-rouge">/home/fastqc</code> directory.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$  ls fastqc/
</code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arabidopsis_sample1_fastqc.html  Arabidopsis_sample2_fastqc.zip   Arabidopsis_sample4_fastqc.html
Arabidopsis_sample1_fastqc.zip	 Arabidopsis_sample3_fastqc.html  Arabidopsis_sample4_fastqc.zip
Arabidopsis_sample2_fastqc.html  Arabidopsis_sample3_fastqc.zip
</code></pre></div></div>

<h2 id="32-viewing-the-fastqc-results">3.2. Viewing the FastQC results</h2>

<p>For each of the samples there are two files. a .html and a .zip</p>

<p>If we were working on our local computer, outside of the container, we‚Äôd be able to display each of these
HTML files as a webpage:</p>

<p>If we were working on our local computers, we‚Äôd be able to display each of these
HTML files as a webpage:</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd fastqc/
$ open Arabidopsis_sample1_fastqc.html
</code></pre></div></div>

<p>However, if you try this in the docker container we‚Äôre working in, you‚Äôll get an error:</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash: open: command not found
</code></pre></div></div>

<p>This is because the container were working in doesn‚Äôt have any web
browsers installed on it, so the remote computer doesn‚Äôt know how to
open the file. We want to look at the webpage summary reports, so
let‚Äôs transfer them to our local computers (i.e. your laptop).</p>

<p>If you‚Äôre also working on a remote computer you will first have to copy 
the files outside of the container using <code class="highlighter-rouge">docker cp</code> and next from the 
remote computer to your local computer with the help of <code class="highlighter-rouge">scp</code>.</p>

<p>First we need to exit the container and next we can transfer our HTML 
files to our local computer using <code class="highlighter-rouge">docker cp</code>.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir -p ~/Desktop/fastqc_html
</code></pre></div></div>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker cp bioinfo:/home/fastqc/ ~/Desktop/fastqc_html
</code></pre></div></div>

<p>This will transfer all files in the folder home/fastqc/ to your Desktop.</p>

<p>bioinfo refers to the name of the container.
The second part starts with a <code class="highlighter-rouge">:</code> and then gives the absolute path of the files you want to transfer.
The third part of the command gives the absolute path of the location
you want to put the files. This is on your local computer and is the
directory we just created <code class="highlighter-rouge">~/Desktop/fastqc_html</code>.</p>

<p>When working on a remote computer make use of the following command</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ scp -r tbliek@genseq-cn02.science.uva.nl:~/rna_seq_lesson/fastqc/ ~/Desktop/fastqc_html
</code></pre></div></div>

<p>As a reminder, the first part
of the command <code class="highlighter-rouge">tbliek@genseq-cn02.science.uva.nl</code> is
the address for your remote computer. Make sure you replace everything
after <code class="highlighter-rouge">dcuser@</code> with your instance number (the one you used to log in).</p>

<p>The second part starts with a <code class="highlighter-rouge">:</code> and then gives the absolute path
of the files you want to transfer from your remote computer. Don‚Äôt
forget the <code class="highlighter-rouge">:</code>. We used a wildcard (<code class="highlighter-rouge">*.html</code>) to indicate that we want all of
the HTML files.</p>

<p>The third part of the command gives the absolute path of the location
you want to put the files. This is on your local computer and is the
directory we just created <code class="highlighter-rouge">~/Desktop/fastqc_html</code>.</p>

<p>The -r option is used to tell scp to recursively copy the source directory and its contents.</p>

<p>You should see a status output like this:</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arabidopsis_sample1_fastqc.html                      100%  249KB 152.3KB/s   00:01    
Arabidopsis_sample2_fastqc.html                       100%  254KB 219.8KB/s   00:01      
</code></pre></div></div>

<p>Now we can go to our new directory and open the HTML files.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/Desktop/fastqc_html/
$ open *.html
</code></pre></div></div>

<p>Your computer will open each of the HTML files in your default web browser. Depending on your settings, this might be as six separate
tabs in a single window or six separate browser windows.</p>

<h3 id="321-decoding-the-fastqc-outputs">3.2.1. Decoding the FastQC outputs</h3>
<p>Upon opening the file Below we have provided a brief overview of interpretations for each of these plots. It‚Äôs important to keep in mind
Now that we have run FASTQC and downloaded the report, we can take a look at the metrics and assess the quality of our sequencing data!</p>

<ul>
  <li><strong>Per tile sequence quality</strong>: the machines that perform sequencing are divided into tiles. This plot displays patterns in base quality along these tiles. Consistently low scores are often found around the edges, but hot spots can also occur in the middle if an air bubble was introduced at some point during the run.</li>
  <li><strong>Per sequence quality scores</strong>: a density plot of quality for all reads at all positions. This plot shows what quality scores are most common.</li>
  <li><strong>Per base sequence content</strong>: plots the proportion of each base position over all of the reads. Typically, we expect to see each base roughly 25% of the time at each position, but this often fails at the beginning or end of the read due to quality or adapter content.</li>
  <li><strong>Per sequence GC content</strong>: a density plot of average GC content in each of the reads.</li>
  <li><strong>Per base N content</strong>: the percent of times that ‚ÄòN‚Äô occurs at a position in all reads. If there is an increase at a particular position, this might indicate that something went wrong during sequencing.</li>
  <li><strong>Sequence Length Distribution</strong>: the distribution of sequence lengths of all reads in the file. If the data is raw, there is often on sharp peak, however if the reads have been trimmed, there may be a distribution of shorter lengths.</li>
  <li><strong>Sequence Duplication Levels</strong>: A distribution of duplicated sequences. In sequencing, we expect most reads to only occur once. If some sequences are occurring more than once, it might indicate enrichment bias (e.g. from PCR). If the samples are high coverage (or RNA-seq or amplicon), this might not be true.</li>
  <li><strong>Overrepresented sequences</strong>: A list of sequences that occur more frequently than would be expected by chance.</li>
  <li><strong>Adapter Content</strong>: a graph indicating where adapater sequences occur in the reads.</li>
</ul>

<p>FastQC has a really well documented <a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/">manual page</a> with <a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/">detailed explanations</a> about every plot in the report.</p>

<p>Within our report, a summary of all of the modules is given on the left-hand side of the report. Don‚Äôt take the <strong>yellow ‚ÄúWARNING‚Äùs</strong> and <strong>red ‚ÄúFAIL‚Äùs</strong> too seriously; they should be interpreted as flags for modules to check out.</p>

<p><img src="../img/fastqc_summary.png" width="200" /></p>

<p>The first module gives the basic statistics for the sample. Generally it is a good idea to keep track of the total number of reads sequenced for each sample and to make sure the read length and %GC content is as expected.</p>

<p><img src="../img/fastqc_basic_stats.png" width="400" /></p>

<p>One of the most important analysis modules is the <strong>‚ÄúPer base sequence quality‚Äù</strong> plot. This plot provides the distribution of quality scores at each position in the read across all reads. This plot can alert us to whether there were any problems occuring during sequencing and whether we might need to contact the sequencing facility.</p>

<p><img src="../img/FastQC_seq_qual.png" alt="FastQC_seq_qual" /></p>

<p>The y-axis gives the quality scores, while the x-axis represents the position in the read. The color coding of the plot denotes what are considered high, medium and low quality scores.</p>

<p>For example, the box plot at nucleotide 1 shows the distribution of quality scores for <strong>the first nucleotide of all reads</strong> in the <code class="highlighter-rouge">Mov10_oe_1</code> sample. The yellow box represents the 25th and 75th percentiles, with the red line as the median. The whiskers are the 10th and 90th percentiles. The blue line represents the average quality score for the nucleotide. Based on these metrics, the quality scores for the first nucleotide are quite high, with nearly all reads having scores above 28.</p>

<p>The quality scores appear to drop going from the beginning toward the end of the reads. For reads generated by Illumina sequencing, this is not unexpected, and there are known causes for this drop in quality. To better interpret this plot it is helpful to understand the different sequencing error profiles.</p>

<h3 id="322-sequencing-error-profiles">3.2.2. Sequencing error profiles</h3>

<p>For Illumina sequencing, the quality of the nucleotide base calls are related to the <strong>signal intensity and purity of the fluorescent signal</strong>. Low intensity fluorescence or the presence of multiple different fluorescent signals can lead to a drop in the quality score assigned to the nucleotide. Due to the nature of sequencing-by-synthesis there are some drops in quality that can be expected, but other quality issues can be indicative of a problem at the sequencing facility.</p>

<p>We will now explore different quality issues arising from the sequencing-by-synthesis used by Illumina, both expected and unexpected.</p>

<h3 id="323-expected-errors">3.2.3. Expected Errors</h3>

<p>As sequencing progresses from the first cycle to the last cycle we often anticipate a drop in the quality of the base calls. This is often due to signal decay and phasing as the sequencing run progresses.</p>

<ul>
  <li><strong>Signal decay:</strong> As sequencing proceeds, the fluorescent signal intensity decays with each cycle, yielding decreasing quality scores at the <strong>3‚Äô end</strong> of the read. This is due to:
    <ol>
      <li>Degrading fluorophores</li>
      <li>A proportion of the strands in the cluster not being elongated</li>
    </ol>

    <p>Therefore, the proportion of signal being emitted continues to decrease with each cycle.</p>

    <p><img src="../img/qc_signal_decay.png" width="400" /></p>
  </li>
  <li><strong>Phasing:</strong> As the number of cycles increases, the signal starts to blur as the cluster loses synchronicity, also yielding a decrease in quality scores at the <strong>3‚Äô end</strong> of the read. As the cycles progress, some strands get random failure of nucleotides to incorporate due to:
    <ol>
      <li>Incomplete removal of the 3‚Äô terminators and fluorophores</li>
      <li>Incorporation of nucleotides without effective 3‚Äô terminators</li>
    </ol>

    <p><img src="../img/qc_phasing.png" width="500" /></p>
  </li>
</ul>

<h3 id="324-worrisome">3.2.4. Worrisome</h3>

<ul>
  <li>
    <p><strong>Overclustering:</strong> Sequencing facilities can overcluster the flow cells, which results in small distances between clusters and an overlap in the signals. The two clusters can be interpreted as a single cluster with mixed fluorescent signals being detected, decreasing signal purity, generating lower quality scores across the <strong>entire read</strong>.</p>

    <p><img src="../img/qc_overclustering.png" width="800" /></p>
  </li>
  <li>
    <p><strong>Instrumentation breakdown:</strong> Sequencing facilities can occasionally have issues with the sequencing instruments during a run. <strong>Any sudden drop in quality or a large percentage of low quality reads across the read could indicate a problem at the facility.</strong> Examples of such issues are shown below, including a manifold burst, cycles lost, and read 2 failure. For such data, the sequencing facility should be contacted for resolution, if possible.</p>

    <p><img src="../img/qc_manifold_burst.png" width="300" /></p>

    <p><img src="../img/qc_cycles_lost.png" width="300" /></p>

    <p><img src="../img/qc_read2_failed.png" width="350" /></p>
  </li>
</ul>

<h3 id="325-quality-assessment">3.2.5. Quality assessment</h3>

<p>Now if we return back to our plot, we can see a drop in quality towards the ends of the reads, which could be explained by signal decay or phasing. No other worrisome signs are present, so the sequencing data from the facility is of good quality.</p>

<p><img src="../img/FastQC_seq_qual.png" alt="FastQC_seq_qual" /></p>

<p>The other modules in the FastQC report can also help interpret the quality of the data.</p>

<h3 id="326-per-sequence-quality-scores">3.2.6. Per sequence quality scores</h3>

<p>The <strong>‚ÄúPer sequence quality scores‚Äù</strong> plot gives you the average quality score on the x-axis and the number of sequences with that average on the y-axis. We hope the majority of our reads have a high average quality score with no large bumps at the lower quality values.</p>

<p><img src="../img/fastqc_per_sequence_quality_scores.png" width="600" /></p>

<p>This data has a small bump at a mean quality of 12. Since it doesn‚Äôt represent a large proportion of the data, it isn‚Äôt extremely worrisome, but it might be worth a quick check of the reads resulting in the poor quality scores.</p>

<h3 id="327-per-base-sequence-content">3.2.7. Per base sequence content</h3>
<p>The next plot gives the <strong>‚ÄúPer base sequence content‚Äù</strong>, which always gives a FAIL for RNA-seq data. This is because the first 10-12 bases result from the ‚Äòrandom‚Äô hexamer priming that occurs during RNA-seq library preparation. This priming is not as random as we might hope giving an enrichment in particular bases for these intial nucleotides.</p>

<p><img src="../img/fastqc_per_base_sequence_content.png" width="600" /></p>

<h3 id="328-per-sequence-gc-content">3.2.8. Per sequence GC content</h3>

<p>The <strong>‚ÄúPer sequence GC content‚Äù</strong> plot gives the GC distribution over all sequences. Generally is a good idea to note whether the GC content of the central peak corresponds to the <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2909565/">expected % GC for the organism</a>. Also, the distribution should be normal unless over-represented sequences (sharp peaks on a normal distribution) or contamination with another organism (broad peak).</p>

<p>This plot would indicate some type of over-represented sequence with the sharp peaks, indicating either contamination or a highly over-expressed gene.</p>

<p><img src="../img/fastqc_GC.png" width="600" /></p>

<h3 id="329-sequence-duplication-level">3.2.9. Sequence duplication level</h3>

<p>The next module explores <strong>numbers of duplicated sequences</strong> in the library. This plot can help identify a low complexity library, which could result from too many cycles of PCR amplification or too little starting material. For RNA-seq we don‚Äôt normally do anything to address this in the analysis, but if this were a pilot experiment, we might adjust the number of PCR cycles, amount of input, or amount of sequencing for future libraries. In this analysis we seem to have a large number of duplicated sequences, but this is can be expected due to the multiple copies of mRNA being duplicates.</p>

<p><img src="../img/fastqc_duplication.png" width="600" /></p>

<h3 id="3210-overrepresented-sequences">3.2.10. Overrepresented sequences</h3>

<p>The <strong>‚ÄúOverrepresented sequences‚Äù</strong> table is another important module as it displays the sequences (at least 20 bp) that occur in more than 0.1% of the total number of sequences. This table aids in identifying contamination, such as vector or adapter sequences. If the %GC content was off in the above module, this table can help identify the source. If not listed as a known adapter or vector, it can help to BLAST the sequence to determine the identity.</p>

<p><img src="../img/FastQC_contam.png" alt="FastQC_contam" /></p>

<p>As our report only represents a subset of reads (chromosome 1) for <code class="highlighter-rouge">Mov10_oe_1.subset.fq</code>, which can skew the QC results. We encourage you to look at the <a href="../fastqc/Mov10oe_1-fastqc_report.html">full set of reads</a> and note how the QC results differ when using the entire dataset.</p>

<p>After exploring the quality of the data, we determine from which gene or transcript the reads originated from using mapping tools. The quality of the data is important when determining where it aligns to on the genome or transcriptome, but the mapping tools we use (salmon and STAR) are able to account for adapter contamination, vector contamination and low-quality bases at the ends of reads. Therefore, after noting any QC issues, we can use our raw reads for the alignment or mapping to the reference genome or transcriptome.</p>

<h2 id="33-working-with-the-fastqc-text-output">3.3. Working with the FastQC text output</h2>

<p>Now that we‚Äôve looked at our HTML reports to get a feel for the data,
let‚Äôs look more closely at the other output files. Go back to the tab
in your terminal program that is connected to your AWS instance
(the tab lab will start with <code class="highlighter-rouge">dcuser@ip</code>) and make sure you‚Äôre in
our results subdirectory.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd home/fastqc/
$ ls
</code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arabidopsis_sample1_fastqc.html  Arabidopsis_sample2_fastqc.zip   Arabidopsis_sample4_fastqc.html
Arabidopsis_sample1_fastqc.zip	 Arabidopsis_sample3_fastqc.html  Arabidopsis_sample4_fastqc.zip
Arabidopsis_sample2_fastqc.html  Arabidopsis_sample3_fastqc.zip
</code></pre></div></div>

<p>Our <code class="highlighter-rouge">.zip</code> files are compressed files. They each contain multiple
different types of output files for a single input FASTQ file. To
view the contents of a <code class="highlighter-rouge">.zip</code> file, we can use the program <code class="highlighter-rouge">unzip</code>
to decompress these files. Let‚Äôs try doing them all at once using a
wildcard.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ conda install -c conda-forge unzip
$ unzip *.zip
</code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Archive:  Arabidopsis_sample1_fastqc.zip
caution: filename not matched:  Arabidopsis_sample2_fastqc.zip
caution: filename not matched:  Arabidopsis_sample3_fastqc.zip
caution: filename not matched:  Arabidopsis_sample4_fastqc.zip
</code></pre></div></div>

<p>This didn‚Äôt work. We unzipped the first file and then got a warning
message for each of the other <code class="highlighter-rouge">.zip</code> files. This is because <code class="highlighter-rouge">unzip</code>
expects to get only one zip file as input. We could go through and
unzip each file one at a time, but this is very time consuming and
error-prone. Someday you may have 500 files to unzip!</p>

<p>A more efficient way is to use a <code class="highlighter-rouge">for</code> loop like we learned in the Shell Genomics lesson to iterate through all of
our <code class="highlighter-rouge">.zip</code> files. Let‚Äôs see what that looks like and then we‚Äôll
discuss what we‚Äôre doing with each line of our loop.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ for filename in *.zip
&gt; do
&gt;  unzip $filename
&gt; done
</code></pre></div></div>

<p>In this example, the input is four filenames (one filename for each of our <code class="highlighter-rouge">.zip</code> files).
Each time the loop iterates, it will assign a file name to the variable <code class="highlighter-rouge">filename</code>
and run the <code class="highlighter-rouge">unzip</code> command.
The first time through the loop,
<code class="highlighter-rouge">$filename</code> is <code class="highlighter-rouge">Arabidopsis_sample1_fastqc.zip</code>.
The interpreter runs the command <code class="highlighter-rouge">unzip</code> on <code class="highlighter-rouge">Arabidopsis_sample1_fastqc.zip</code>.
For the second iteration, <code class="highlighter-rouge">$filename</code> becomes
<code class="highlighter-rouge">Arabidopsis_sample2_fastqc.zip</code>. This time, the shell runs <code class="highlighter-rouge">unzip</code> on <code class="highlighter-rouge">Arabidopsis_sample2_fastqc.zip</code>.
It then repeats this process for the four other <code class="highlighter-rouge">.zip</code> files in our directory.</p>

<p>When we run our <code class="highlighter-rouge">for</code> loop, you will see output that starts like this:</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Archive:  fastqc/Arabidopsis_sample2_fastqc.zip
   creating: Arabidopsis_sample2_fastqc/
   creating: Arabidopsis_sample2_fastqc/Icons/
   creating: Arabidopsis_sample2_fastqc/Images/
  inflating: Arabidopsis_sample2_fastqc/Icons/fastqc_icon.png  
  ...
  inflating: Arabidopsis_sample4_fastqc/Images/duplication_levels.png  
  inflating: Arabidopsis_sample4_fastqc/Images/adapter_content.png  
  inflating: Arabidopsis_sample4_fastqc/fastqc_report.html  
  inflating: Arabidopsis_sample4_fastqc/fastqc_data.txt  
  inflating: Arabidopsis_sample4_fastqc/fastqc.fo 
</code></pre></div></div>

<p>The <code class="highlighter-rouge">unzip</code> program is decompressing the <code class="highlighter-rouge">.zip</code> files and creating
a new directory (with subdirectories) for each of our samples, to
store all of the different output that is produced by FastQC. There
are a lot of files here. The one we‚Äôre going to focus on is the
<code class="highlighter-rouge">summary.txt</code> file.</p>

<p>If you list the files in our directory now you will see:</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arabidopsis_sample1_fastqc     	 Arabidopsis_sample2_fastqc.html  Arabidopsis_sample3_fastqc.zip
Arabidopsis_sample1_fastqc.html  Arabidopsis_sample2_fastqc.zip   Arabidopsis_sample4_fastqc
Arabidopsis_sample1_fastqc.zip	 Arabidopsis_sample3_fastqc	  Arabidopsis_sample4_fastqc.html
Arabidopsis_sample2_fastqc	 Arabidopsis_sample3_fastqc.html  Arabidopsis_sample4_fastqc.zip
</code></pre></div></div>

<p>The <code class="highlighter-rouge">.html</code> files and the uncompressed <code class="highlighter-rouge">.zip</code> files are still present,
but now we also have a new directory for each of our samples. We can
see for sure that it‚Äôs a directory if we use the <code class="highlighter-rouge">-F</code> flag for <code class="highlighter-rouge">ls</code>.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls -F
</code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arabidopsis_sample1_fastqc/	 Arabidopsis_sample2_fastqc.html  Arabidopsis_sample3_fastqc.zip   
Arabidopsis_sample1_fastqc.html  Arabidopsis_sample2_fastqc.zip   Arabidopsis_sample4_fastqc/
Arabidopsis_sample1_fastqc.zip	 Arabidopsis_sample3_fastqc/	  Arabidopsis_sample4_fastqc.html
Arabidopsis_sample2_fastqc/	 Arabidopsis_sample3_fastqc.html  Arabidopsis_sample4_fastqc.zip
</code></pre></div></div>

<p>Let‚Äôs see what files are present within one of these output directories.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls -F Arabidopsis_sample1_fastqc/
</code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fastqc_data.txt  fastqc.fo  fastqc_report.html	Icons/	Images/  summary.txt
</code></pre></div></div>

<p>Use <code class="highlighter-rouge">less</code> to preview the <code class="highlighter-rouge">summary.txt</code> file for this sample.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ less Arabidopsis_sample1_fastqc/summary.txt
</code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PASS    Basic Statistics        Arabidopsis_sample1.fq.gz
PASS    Per base sequence quality       Arabidopsis_sample1.fq.gz
PASS    Per sequence quality scores     Arabidopsis_sample1.fq.gz
FAIL    Per base sequence content       Arabidopsis_sample1.fq.gz
PASS    Per sequence GC content Arabidopsis_sample1.fq.gz
PASS    Per base N content      Arabidopsis_sample1.fq.gz
PASS    Sequence Length Distribution    Arabidopsis_sample1.fq.gz
WARN    Sequence Duplication Levels     Arabidopsis_sample1.fq.gz
WARN    Overrepresented sequences       Arabidopsis_sample1.fq.gz
PASS    Adapter Content Arabidopsis_sample1.fq.gz
</code></pre></div></div>

<p>The summary file gives us a list of tests that FastQC ran, and tells
us whether this sample passed, failed, or is borderline (<code class="highlighter-rouge">WARN</code>). Remember to quit from <code class="highlighter-rouge">less</code> you enter <code class="highlighter-rouge">q</code>.</p>

<h2 id="34-documenting-our-work">3.4. Documenting our work</h2>

<p>We can make a record of the results we obtained for all our samples
by concatenating all of our <code class="highlighter-rouge">summary.txt</code> files into a single file
using the <code class="highlighter-rouge">cat</code> command. We‚Äôll call this <code class="highlighter-rouge">full_report.txt</code> and move
it to <code class="highlighter-rouge">~/dc_workshop/docs</code>.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat */summary.txt &gt; fastqc_summaries.txt
</code></pre></div></div>

<h1 id="4-trimming-and-filtering">4. Trimming and filtering</h1>

<p>Before we will do the alignment we need to remove sequences of low quality and sequences that are to short (below 25 bases).
Also in this case we will trim down long sequences to 100 bases, quality of the Ion-torrent reads drops the further it gets.
When making use of illumina reads this is not as much of a problem and 3‚Äô-trimming would then be a waste of data.</p>

<p>To start off make a directory trimmed for the output and then back to the rawReads directory.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /home/
$ mkdir trimmed
</code></pre></div></div>

<p>The trimming and quality filtering will be done with <strong>trimmomatic</strong>.
In the programm the following arguments can be used.</p>

<table>
  <thead>
    <tr>
      <th>step</th>
      <th>meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">SE</code> or <code class="highlighter-rouge">PE</code></td>
      <td>Reads are single end or paired end.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ILLUMINACLIP</code></td>
      <td>Perform adapter removal</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">SLIDINGWINDOW</code></td>
      <td>Perform sliding window trimming, cutting once the average quality within the window falls below a threshold.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">LEADING</code></td>
      <td>Cut bases off the start of a read, if below a threshold quality.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TRAILING</code></td>
      <td>Cut bases off the end of a read, if below a threshold quality.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">CROP</code></td>
      <td>Cut the read to a specified length.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">HEADCROP</code></td>
      <td>Cut the specified number of bases from the start of the read.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MINLEN</code></td>
      <td>Drop an entire read if it is below a specified length.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TOPHRED33</code></td>
      <td>Convert quality scores to Phred-33.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TOPHRED64</code></td>
      <td>Convert quality scores to Phred-64.</td>
    </tr>
  </tbody>
</table>

<p>To run this on a single sample it looks something like this</p>
<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trimmomatic SE -phred33 -threads 2 Arabidopsis_sample1.fq.gz trimmed/Arabidopsis_sample1_qc.fq ILLUMINACLIP:adapters.fasta:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:25
</code></pre></div></div>

<p>Of cource we don‚Äôt want to do this for all the reads seperately so lets create a loop through all the fastq files.</p>

<p>When doing the fastqc only input files needed to be specified. In this case both the input and a matching output filenames need to be given.
this can be done with the help of ‚Äòbasename‚Äô</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ for infile in *.fq.gz
do
 echo inputfile $infile
 outfile="$(basename $infile .fq.gz)"_qc.fq
 echo outputfile $outfile
 echo
done
</code></pre></div></div>

<p>This be be producing the following list</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inputfile Arabidopsis_sample1.fq.gz
outputfile Arabidopsis_sample1_qc.fq

inputfile Arabidopsis_sample2.fq.gz
outputfile Arabidopsis_sample2_qc.fq

inputfile Arabidopsis_sample3.fq.gz
outputfile Arabidopsis_sample3_qc.fq

inputfile Arabidopsis_sample4.fq.gz
outputfile Arabidopsis_sample4_qc.fq
</code></pre></div></div>

<p>Next we can start writing the trimmomatic loop.
Again starting with a dry run with echo.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ for infile in *.fq.gz
do
  outfile="$(basename $infile .fq.gz)"_qc.fq
  echo "trimmomatic SE -phred33 -threads 2 $infile trimmed/$outfile ILLUMINACLIP:adapters.fasta:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:25"
done
</code></pre></div></div>

<p>should be producing something like this</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trimmomatic SE -phred33 -threads 2 Arabidopsis_sample1.fq.gz trimmed/Arabidopsis_sample1.fq.gz_qc.fq ILLUMINACLIP:adapters.fasta:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:25
trimmomatic SE -phred33 -threads 2 Arabidopsis_sample2.fq.gz trimmed/Arabidopsis_sample2.fq.gz_qc.fq ILLUMINACLIP:adapters.fasta:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:25
trimmomatic SE -phred33 -threads 2 Arabidopsis_sample3.fq.gz trimmed/Arabidopsis_sample3.fq.gz_qc.fq ILLUMINACLIP:adapters.fasta:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:25
trimmomatic SE -phred33 -threads 2 Arabidopsis_sample4.fq.gz trimmed/Arabidopsis_sample4.fq.gz_qc.fq ILLUMINACLIP:adapters.fasta:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:25
</code></pre></div></div>

<p>If it all looks ok, rerun with out <code class="highlighter-rouge">echo</code></p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ for infile in *.fq.gz
do
    outfile="$(basename $infile .fq.gz)"_qc.fq
    trimmomatic SE -phred33 -threads 2 $infile ../trimmed/"$outfile ILLUMINACLIP:../general/adapters.fasta:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:25 CROP:100
done

</code></pre></div></div>

<p>The following should appear:</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TrimmomaticSE: Started with arguments:
 -phred33 -threads 2 Arabidopsis_sample1.fq.gz trimmed/Arabidopsis_sample1.fq.gz_qc.fq ILLUMINACLIP:adapters.fasta:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:25
Using Long Clipping Sequence: 'GATCGGAAGAGCACACGTCTGAACTCCAGTCACTGACCAATCTCGTATGCCGTCTTCTGCTTG'
Using Long Clipping Sequence: 'CAAGCAGAAGACGGCATACGAGCTCTTCCGATCT'
‚Ä¶
Skipping duplicate Clipping Sequence: 'ACACTCTTTCCCTACACGACGCTCTTCCGATCT'
ILLUMINACLIP: Using 0 prefix pairs, 31 forward/reverse sequences, 0 forward only sequences, 0 reverse only sequences
Input Reads: 250000 Surviving: 248320 (99.33%) Dropped: 1680 (0.67%)
TrimmomaticSE: Completed successfully
</code></pre></div></div>

<p>It‚Äôs possible to scroll up to check if the percentage of surviving &amp; dropped is within the same range in all of the samples.</p>

<h1 id="5-alignment-to-a-reference-genome">5. Alignment to a reference genome</h1>

<p><img src="../img/RNAseqWorkflow.png" height="400" /></p>

<p>We perform read alignment or mapping to determine where in the genome our reads originated from. There are a number of tools to
choose from and, while there is no gold standard, there are some tools that are better suited for particular NGS analyses. In this tutorial we will be using <a href="https://physiology.med.cornell.edu/faculty/skrabanek/lab/angsd/lecture_notes/STARmanual.pdf">STAR</a> but also 
a tool like <a href="http://ccb.jhu.edu/software/hisat2/index.shtml">hisat2</a> does the job.</p>

<p><strong>STAR Alignment Strategy</strong></p>

<p>STAR is shown to have high accuracy and outperforms other aligners by more than a factor of 50 in mapping speed, but it is memory intensive. The algorithm achieves this highly efficient mapping by performing a two-step process:</p>

<p>Seed searching
Clustering, stitching, and scoring
Seed searching</p>

<p>For every read that STAR aligns, STAR will search for the longest sequence that exactly matches one or more locations on the reference genome. These longest matching sequences are called the Maximal Mappable Prefixes (MMPs):</p>

<p><img src="../img/alignment_STAR_step1.png" height="350" /></p>

<p>The different parts of the read that are mapped separately are called ‚Äòseeds‚Äô. So the first MMP that is mapped to the genome is called seed1.</p>

<p>STAR will then search again for only the unmapped portion of the read to find the next longest sequence that exactly matches the reference genome, or the next MMP, which will be seed2.</p>

<p><img src="../img/alignment_STAR_step2.png" height="275" /></p>

<p>This sequential searching of only the unmapped portions of reads underlies the efficiency of the STAR algorithm. STAR uses an uncompressed suffix array (SA) to efficiently search for the MMPs, this allows for quick searching against even the largest reference genomes. Other slower aligners use algorithms that often search for the entire read sequence before splitting reads and performing iterative rounds of mapping.</p>

<p>If STAR does not find an exact matching sequence for each part of the read due to mismatches or indels, the previous MMPs will be extended.</p>

<p><img src="../img/alignment_STAR_step3.png" height="650" /></p>

<p><strong>If extension does not give a good alignment</strong>, then the poor quality or adapter sequence (or other contaminating sequence) will be soft clipped.</p>

<p><img src="../img/alignment_STAR_step4.png" height="300" /></p>

<p><strong>Clustering, stitching, and scoring</strong></p>

<p>The separate seeds are stitched together to create a complete read by first clustering the seeds together based on proximity to a set of ‚Äòanchor‚Äô seeds, or seeds that are not multi-mapping.</p>

<p>Then the seeds are stitched together based on the best alignment for the read (scoring based on mismatches, indels, gaps, etc.).</p>

<p><img src="../img/alignment_STAR_step5.png" height="400" /></p>

<p><strong>The alignment process consists of two steps:</strong></p>

<ol>
  <li>Indexing the reference genome</li>
  <li>Aligning the reads to the reference genome</li>
</ol>

<p><strong>Setting up</strong></p>

<h2 id="51-index-the-reference-genome">5.1. Index the reference genome</h2>
<p>Our first step is to index the reference genome for use by STAR. Indexing allows the aligner to quickly find potential alignment sites for query sequences in a genome, which saves time during alignment. Indexing the reference only has to be run once. The only reason you would want to create a new index is if you are working with a different reference genome or you are using a different tool for alignment (index files are not exchangeable between tools).</p>

<p>Take note that depending on the genome size these index files produced by STAR can be pretty big. Make sure there‚Äôs enough disk space available.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /home/

$ mkdir genomeIndex

$ gunzip AtChromosome1.fa.gz

$ STAR --runMode genomeGenerate --genomeDir genomeIndex --genomeFastaFiles AtChromosome1.fa --runThreadN 2
</code></pre></div></div>

<p>While the index is created, you will see output something like this:</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Apr 29 16:55:14 ..... Started STAR run
Apr 29 16:55:14 ... Starting to generate Genome files
Apr 29 16:55:16 ... starting to sort  Suffix Array. This may take a long time...
Apr 29 16:55:16 ... sorting Suffix Array chunks and saving them to disk...
Apr 29 16:56:13 ... loading chunks from disk, packing SA...
Apr 29 16:56:26 ... writing Suffix Array to disk ...
Apr 29 16:56:27 ... Finished generating suffix array
Apr 29 16:56:27 ... starting to generate Suffix Array index...
Apr 29 16:56:48 ... writing SAindex to disk
Apr 29 16:57:00 ..... Finished successfully

</code></pre></div></div>

<p>The indexing should have produced 8 star index files. Use the following command to see if they‚Äôre really there.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls -l genomeIndex/
</code></pre></div></div>

<p>result should be:</p>
<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-rw-r--r-- 1 tbliek genseq-local          9 Apr 29 16:55 chrLength.txt
-rw-r--r-- 1 tbliek genseq-local         14 Apr 29 16:55 chrNameLength.txt
-rw-r--r-- 1 tbliek genseq-local          5 Apr 29 16:55 chrName.txt
-rw-r--r-- 1 tbliek genseq-local         11 Apr 29 16:55 chrStart.txt
-rw-r--r-- 1 tbliek genseq-local   30670848 Apr 29 16:55 Genome
-rw-r--r-- 1 tbliek genseq-local        290 Apr 29 16:55 genomeParameters.txt
-rw-r--r-- 1 tbliek genseq-local  249672325 Apr 29 16:56 SA
-rw-r--r-- 1 tbliek genseq-local 1565873616 Apr 29 16:56 SAindex
</code></pre></div></div>

<h2 id="52-align-reads-to-reference-genome">5.2. Align reads to reference genome</h2>

<p>In some tools like hisat2 creating the sequence alignment files (bam-files) is done in two steps. first the aligning it self. After that the alignment file will be filtered for instance to only contain the reads that actualy map to the genome. This is done with <a href="https://broadinstitute.github.io/picard/explain-flags.html">sam flags</a> in samtools view (with the ‚Äò-F 4‚Äô all the unmapped reads will be removed). STAR on the other hand has a build in filter and also a sort function. So the output is ready to use for downstream tools.</p>

<p>First of course we will need to create a directory to output the alignment files</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /home/

$ mkdir mapped
</code></pre></div></div>

<p>Running STAR to align ( or map ) the reads and optionaly filter and sort them.</p>

<p>In contrast to most tools, STAR does not have a help function.
running STAR -h or STAR ‚Äìhelp will result in an error. For information on what arguments to use you can 
use have a look at the 
<a href="https://physiology.med.cornell.edu/faculty/skrabanek/lab/angsd/lecture_notes/STARmanual.pdf">STAR manual.</a>.</p>

<p>Here are some examples of common used arguments.</p>

<table>
  <thead>
    <tr>
      <th>argument</th>
      <th>meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">--runThreads</code></td>
      <td>number of threads</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--genomeDir</code></td>
      <td>/path/to/genomeDir</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--readFilesIn</code></td>
      <td>/path/to/read1 [/path/to/read2]</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--readFilesCommand zcat</code></td>
      <td>when making use of gzipped fastq files</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--outFileNamePrefix</code></td>
      <td>/path/to/output file name</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--outSAMtype</code></td>
      <td>BAM/SAM or None  [optional: SortedByCoordinate]</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--outReadsUnmapped</code></td>
      <td>[default: None] Fastx ; output in separate fasta/fastq file</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--outFilterMultimapNmax</code></td>
      <td>[default: 10] max number of alignments accepted</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--outFilterMismatchNmax</code></td>
      <td>[default: 10] max number of mismatches accepted</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--outFilterMismatchNoverLmax</code></td>
      <td>[default: 0.3] max fraction of mismatches mapped length</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--outFilterMismatchNoverReadLmax</code></td>
      <td>[default: 1.0] max fraction of mismatches read length</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">--alignEndsType</code></td>
      <td>EndToEnd force end-to-end alignment, don‚Äôt soft-clip</td>
    </tr>
  </tbody>
</table>

<p>For now we will be using STAR with the following arguments</p>
<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$  STAR --genomeDir genomeIndex --runThreadN 2 --readFilesIn trimmed/Arabidopsis_sample1_qc.fq --outFileNamePrefix mapped/Arabidopsis_sample1_qc --outSAMtype BAM SortedByCoordinate --outSAMunmapped None --outFilterMismatchNmax 3 --outFilterMultimapNmax 1 --outSAMattributes All
</code></pre></div></div>

<p>Next we want to make a loop to do all the files</p>

<p>It‚Äôs good again to first start with a ‚Äòdry‚Äô run with the use of echo</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ for infile in trimmed/*.fq
 do
   outfile="$(basename $infile .fq)"_
   echo "STAR --genomeDir genomeIndex --runThreadN 2 --readFilesIn trimmed/$infile --outFileNamePrefix mapped/$outfile --outSAMtype BAM SortedByCoordinate --outSAMunmapped None --outFilterMismatchNmax 3 --outFilterMultimapNmax 1 --outSAMattributes All"
 done
</code></pre></div></div>

<p>If the commands look good, rerun but this time without the echo.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$for infile in trimmed/*.fq
 do
   outfile="$(basename $infile .fq)"_
   STAR --genomeDir genomeIndex --runThreadN 2 --readFilesIn trimmed/$infile --outFileNamePrefix mapped/$outfile --outSAMtype BAM SortedByCoordinate --outSAMunmapped None --outFilterMismatchNmax 3 --outFilterMultimapNmax 1 --outSAMattributes All
 done
</code></pre></div></div>

<p>When running the STAR command, you will see output something like this:</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>May 04 12:51:55 ..... Started STAR run
May 04 12:52:47 ..... Started mapping
May 04 12:55:06 ..... Started sorting BAM
May 04 12:55:59 ..... Finished successfully
</code></pre></div></div>

<p>The final.out file contains all the characteristics of the alignment.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ less mapped/Arabidopsis_sample1_qc.final.out
</code></pre></div></div>

<p>resulting in table containing all the alignment values.</p>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                 Started job on |       May 04 12:51:55
                             Started mapping on |       May 04 12:52:47
                                    Finished on |       May 04 12:55:59
       Mapping speed, Million of reads per hour |       156.56

                          Number of input reads |       8349970
                      Average input read length |       101
                                    UNIQUE READS:
                   Uniquely mapped reads number |       8047613
                        Uniquely mapped reads % |       96.38%
                          Average mapped length |       100.60
                       Number of splices: Total |       2243517
            Number of splices: Annotated (sjdb) |       0
                       Number of splices: GT/AG |       2223720
                       Number of splices: GC/AG |       16101
                       Number of splices: AT/AC |       479
               Number of splices: Non-canonical |       3217
                      Mismatch rate per base, % |       0.24%
                         Deletion rate per base |       0.00%
                        Deletion average length |       1.30
                        Insertion rate per base |       0.01%
                       Insertion average length |       1.11
                             MULTI-MAPPING READS:
        Number of reads mapped to multiple loci |       300104
             % of reads mapped to multiple loci |       3.59%
        Number of reads mapped to too many loci |       385
             % of reads mapped to too many loci |       0.00%
                                  UNMAPPED READS:
       % of reads unmapped: too many mismatches |       0.00%
                 % of reads unmapped: too short |       0.02%
                     % of reads unmapped: other |       0.00%
Arabidopsis_sample1_qcLog.final.out (END) 
</code></pre></div></div>

<h2 id="53-the-sambam-format">5.3. The SAM/BAM format</h2>
<p>The <a href="https://github.com/adamfreedman/knowyourdata-genomics/blob/gh-pages/lessons/01-know_your_data.md#aligned-reads-sam">SAM file</a>,
is a tab-delimited text file that contains information for each individual read and its alignment to the genome. While we do not
have time to go in detail of the features of the SAM format, the paper by
<a href="http://bioinformatics.oxfordjournals.org/content/25/16/2078.full">Heng Li et al.</a> provides a lot more detail on the specification.</p>

<p><strong>The compressed binary version of SAM is called a BAM file.</strong> We use this version to reduce size and to allow for <em>indexing</em>, which enables efficient random access of the data contained within the file.</p>

<p>The file begins with a <strong>header</strong>, which is optional. The header is used to describe source of data, reference sequence, method of
alignment, etc., this will change depending on the aligner being used. Following the header is the <strong>alignment section</strong>. Each line
that follows corresponds to alignment information for a single read. Each alignment line has <strong>11 mandatory fields</strong> for essential
mapping information and a variable number of other fields for aligner specific information. An example entry from a SAM file is
displayed below with the different fields highlighted.</p>

<p><img src="../img/sam_bam_1.png" /></p>

<p><img src="../img/sam_bam2.png" /></p>

<h1 id="6-creating-the-counts-file">6. Creating the counts file</h1>

<p>For downstream application for each of the samples the number of reads that maps within a gene has to be determined.
Featurecounts from the subread package can do this.</p>

<p>FeatureCounts can count the number of reads that map within a feature. In case of the arabidopsis annotation there are three different features to choose from. Depending on the downstream applications the choice is gene, transcript or exon. In this study we are just looking for differientially expressed genes.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /home/

$ gunzip ath_annotation.gff3.gz

$ featureCounts -O -t gene -g ID -a ath_annotation.gff3 -o counts.txt mapped/*.bam
</code></pre></div></div>

<p>-a <string>         Name of an annotation file. GTF/GFF format by default.
-o <string>         Name of the output file including read counts.
-O                  Assign reads to all their overlapping meta-features.
-t <string>         Specify feature type in GTF annotation
-g <string>         Specify attribute type in GTF annotation. Determines the name of the features.</string></string></string></string></p>

<p>The output file produced by <code class="highlighter-rouge">featureCounts</code> is a tab-delimited file, can be opened in a program like excel.</p>

<h1 id="7-removal-of-container-and-image">7. Removal of Container and Image</h1>

<p>If you have run this lesson locally and finished it all you might want to remove the container and the image (occupies about 4 gb of space).</p>

<p>If there are file you want to save copy them using <code class="highlighter-rouge">docker cp</code> as mentioned earlier in this lesson.</p>

<p>First you can stop the container and remove it.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker stop bioinfo

$ docker rm bioinfo
</code></pre></div></div>

<p>To check if all the containers using the image are gone run</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker ps -a
</code></pre></div></div>

<p>This will show a list of the conainers, and the image they make use of.</p>

<p>If empty for the image in question, run the following to get the ID of the image.</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker images
</code></pre></div></div>

<p>Copy the image id from the output</p>
<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPOSITORY                         TAG                 IMAGE ID            CREATED             SIZE
scienceparkstudygroup/master-gls   fastq-latest        daef7efb73ec        4 days ago          1.36GB
</code></pre></div></div>

<p>To remove the image run</p>

<div class="bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker rmi daef7efb73ec
</code></pre></div></div>

<h1 id="8-keypoints">8. Keypoints</h1>
:ET